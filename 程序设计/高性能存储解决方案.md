## 关系型数据库



- 主从复制 保证高可用
- 读写分离 确保高性能



### **读写分离**

---

读写分离实现的逻辑并不复杂，可以借助中间件如MySQL-router，也可以使用Spring AOP来简单实现。

但是如何处理读写分离带来的系统复杂性，需要解决。如 ：



**主从复制的延迟**，造成读写分离的数据不一致

解决办法有三类：

1. 重要的操作指定到主服务器去读

   主服务器的压力挺大。

2. 读从服务器没有读到，去主服务器再查一次

   缺点是需要两次查询，性能较差。

3. 写操作之后读，去主服务器去读

   代码耦合性高，而且延迟不是固定的。



### 分库分表

---

单表两千万就需要考虑分库分表了。数据量大带来的问题有：

- 读写性能差，大数据量就意味着更高的树，更多的IO次数。
- 数据文件很大，备份和恢复也很困难。
- 对大表进行DDL操作也会非常缓慢，会锁表一个小时以上。



> 大表DDL有两种解决办法：
>
> 1. 使用临时表，先用临时表DDL再重命名
> 2. 使用pt online工具



**分库**

分库常用的是根据业务来分库，如用户数据单独一个库，订单数据单独一个库。

这样带来的问题也显而易见 ：

- join操作更麻烦了
  - 同一个服务，只需要带上表名前面加上库名就可以了【同一个服务器分不分库有啥区别】
  - 不同服务器，需要federated引擎【太麻烦了，不实用】
  - 用代码实现join操作【实现复杂】
- 分布式事务
  - MySQL的XA事务【效率低】
  - 用代码实现【借助MQ、Seata】
- 成本问题
  - 本来一台服务器搞定，现在要多台。初创业务，大多数没必要上多台吧。
  - 如果初创业务从零开始，单台服务器就足够支撑10w用户了。并且前期可能没有那么多的人手和财力，可以考虑等业务发展起来，再做分库分表。



**分表**

分表的优势是，可以提高读写的速度；但是另一角度，也会增加查询的复杂度。



分表有两种 ：

- 垂直分表
- 水平分表



**垂直分表**

就是将一个表的垂直分割开。把一些列拆分出去。

查询的时候使用join操作。



**水平分表**

将一个表水平分割。

分割的方法有 ：

1. 根据范围路由

   优点是可以平滑扩容。缺点是，分布的可能不是很均匀。

2. 根据hash路由

   优点是分布的很均匀，缺点是扩容很麻烦

3. 使用一张配置表来路由

   优点是方便灵活，缺点是需要查询两次。或者需要维护一个本地缓存。



水平分割的缺点 ：

- join操作复杂【需要用代码来实现了】
- count要查多张表【代码实现或者用一张表来记录】
- order by需要用代码来实现了
- 如果不是通过id来查，那就需要查多张表了



## NoSQL

关系型数据库凭借着ACID特性，在多数场景都可以使用。但是也是有缺点的，比如：

- 存储于磁盘，需要IO，性能瓶颈。并且是以行为单位去存储，有时候不需要读取整个行。
- 全文搜索较弱
- 大表的DDL很不方便，修改schema要数个小时
- 没办法存储数据结构，比如set，保存关注的人



以上缺点，催生了NoSQL，如：

- Redis ：基于内存，可以存储数据结构
- MongoDB ：解决了关系型数据库schema强约束，直接存储JSON
- HBase：列式存储，减少IO压力。可以只读取某些列
- ElasticSearch ：全文检索。弥补like查询的短板



## 缓存引入引起的问题

引入了缓存，一方面提高了性能，但另一方面增加了系统的复杂度，需要保证缓存的高可用。

在部署上更复杂一些。



除此之外，也有一些其他问题。



**缓存穿透**

查询了一个根本不存在的数据，导致做了一次无效的数据库查询。

或者查询一次非常耗时，如果缓存失效，那么这次查询将会非常耗时。



解决办法：

- 引入布隆过滤器，将所有的数据都放入布隆过滤器，当确定布隆过滤器可能存在时，才去查数据库
- 将非法查询的key也放入缓存中
- 参数校验
- 耗时的操作，直接放入缓存中，定时去更新，不设置过期时间



**缓存雪崩**

短时间内，大批量key过期，导致大量的查询直达数据库，数据库压力倍增。



解决办法是 ：

- 设置过期时间时，加上一个随机值
- 熔断机制



**缓存击穿**

单个热点key过期了，导致大量相同的查询到达数据库。



解决办法是 ：

- 引入更新锁，拿到更新锁的线程去查询并放入缓存中；其他线程阻塞后去缓存中查找
- 使用消息队列，线程查到缓存中没有的话，发消息通知监听者去查找。
- 热点key永不过期