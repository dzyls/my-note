## 网络IO

与高性能相关的因素有很多，比如磁盘、cpu、内存、缓存、网络、语言、编码水平、架构都会影响到。

一行不恰当的debug日志、一次低效的SQL查询，都有可能会大幅度降低整个系统的TPS。

甚至一个tcp_nodelay参数，都会影响到响应时间。



高性能架构通常集中在两个方面 ：

- 压榨单机的性能
- 如果单机的性能不能满足，则需要搭建集群



选择一个合适的网络IO模型，是至关重要的，关乎性能和吞吐量。



**如何理解同步、异步、阻塞、非阻塞**

IO可分为两步 ：

- 数据拷贝到内核空间
- 从内核空间拷贝到用户空间

如果数据拷贝到内核空间是等待的，那么是阻塞的。

如果数据从内核空间拷贝到用户空间是等待的，那么是同步的，反之是异步的。



Java中的IO有 ：

- BIO ：同步阻塞。一个连接一个线程，可以使用线程池来减少创建线程的开销
- NIO ：同步非阻塞。在数据拷贝到内核空间的这段时间，用户线程没有阻塞，轮询去询问内核数据是否拷贝完成。
- AIO ：异步非阻塞。在两次拷贝都没有阻塞。



Java的NIO基于IO多路复用技术【不管是select或者是epoll】。



**基于BIO的模型**

BIO的思想是，一个连接一个线程【或者一个进程】，可以使用线程池来优化，避免频繁创建线程造成的资源浪费。

但，如果使用了线程池，线程池本身的数量就是有限的【限流】，并且如果阻塞于read、write操作时，线程其实是一直在等待的，这种很浪费。

BIO的优点是 ：设计简单、易于理解，适合那种并发量一百多个那种。



**Reactor**

多路 ：多个连接

复用 ：使用同一个阻塞对象【或者说是线程、进程】。

为什么要复用同一个阻塞对象？如果不复用，并且使用一个线程去管理多个连接，那么就需要这个线程不断去轮询连接。这样会造成CPU资源浪费。



select基于轮询，并且基于数组、有数量限制，返回的是有事件发送的连接的数量。

poll也是基于轮询，但是基于链表，没有数量限制。两者都是监听的连接越多，性能越差。

epoll是基于回调函数，数量多性能不一定差。底层使用了红黑树存储要监听的连接，链表保存发生了事件的连接。并且支持边缘触发。



**单Reactor单线程**

一个Reactor，一个进程\线程。

Reactor会根据不同的事件类型，调用不同的函数去处理。

优点是：简单、易于理解。

缺点是：没有充分的利用多核CPU的优势。

Redis在6.0之前使用的是这种模型。



**单Reactor多线程**





