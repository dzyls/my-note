### 如何辨别是不是垃圾

---

1. 引用计数法

   无法解决循环引用的情况，Python使用的是这种，但是对循环引用做了特殊处理。

2. 可达性分析

   Java使用的是这种。从GC Root向下遍历，引用链达到的对象即为有效对象。

可以作为GC Root的对象 ：

1. Java虚拟机栈引用的对象
2. 本地方法栈引用的对象
3. 静态变量
4. 常量
5. JVM使用的一些对象（如Class对象、Classloader对象、常用的异常对象）
6. synchroized持有的对象
7. 反应JVM内部情况的对象，如JMX Bean



除此之外，引用也分为：

- 强引用 ：任何时候都不会回收的对象
- 软引用 ：内存不足时回收的对象
- 弱引用 ：下次垃圾回收时回收的对象
- 虚引用 ：没什么用，可以用来接收到对象被回收的通知



**Finalize方法**

finalize方法是对象可以自救的一个方法。

一个对象被回收要经过两次垃圾回收，第一次判断有没有重写finalize方法或者有没有执行，如果此对象需要执行finalize方法，那么将会放到一个低优先级队列中。Java不保证这个finalize方法一定会执行完。

第二次回收判断这个对象之前标记过一次，就会真正的执行。



**不用使用finalize方法关闭资源，使用try-finally**



**方法区（元空间）回收**

元空间存储的是类的二进制信息，当存在以下情况就会回收 ：

- 类的所有实例对象都被回收
- 类的类加载器已经被回收（比如JSP）
- 没有任何一个地方使用了这个类的Class对象，无法通过反射来操作这个类



### 分代收集

---

在垃圾回收中，存在两种极端。

- 大部分对象朝生夕死，很快就会被垃圾回收。
- 少部分对象存活时间很长

针对这两种情况，在之前的垃圾回收器中，都是采用分代收集算法。

存活时间很短的，放在年轻代。存活时间很长的，放在老年代。

年轻代采用复制算法，因为对象很快就会被回收。

根据不同情况，采用不同的处理方法，这也是系统设计或功能设计经常采用的方法。

**但是这种分代，会有另外一个问题 ：跨代引用**

如果老年代引用了某个年轻代的对象，那么要判断这个年轻代对象是否要回收，就要遍历整个老年代了。

针对这种情况，采用了记忆集（Remember Set）。记忆集保存了老年代哪些区域引用了年轻代对象，判断年轻代对象是否被引用，只需要扫描老年代的部分区域即可。



垃圾回收算法有三种 ：

- 复制算法 ：会有空间浪费
- 标记清除算法，会有内存碎片
- 标记整理算法：需要STW



### 垃圾回收的步骤

---

**根节点枚举**

Java是使用可达性分析来做垃圾回收的，因此第一个步骤肯定是找到GC Root。

这个过程称必然要暂停用户线程，以避免用户线程又加了或者减了GC Root。

JVM通过一个OopMap的数据结构来快速找到GC Root。



**安全点**

OopMap的原理是，在可能导致引用变化的指令生成对应的OopMap。但是可能导致引用变化的指令太多了，不可能全部都生成对应的OopMap。因此只在特定的位置来记录这些信息，比如方法调用、循环跳转、异常跳转等。

让所有的线程都到达安全点，停顿下来，一般有两种方式。

- 抢先式中断 ：抢先式中断比较强硬，当需要GC时，直接把所有的线程中断；如果有线程不在安全点上，就回复这个线程。这种是比较低效的。
- 主动式中断 ：当需要GC时，设置一个标志位，然后用户线程都去轮询这个这个标志位，查到就在安全点暂停。



**安全区域**

有些用户线程一直没有得到cpu，一直阻塞或者等待。那么就不能去检查标志位走到安全点。因此引入了另外一个概念 ：安全区域。线程进入安全区域，会标识自己进入了安全区域，这样JVM就不用管这些线程；当线程离开安全区域，会去检测GC Root是否已经完成。由此来保证在遍历GC Root时不会引起引用变化。



**记忆集**

跨代引用，为了避免扫描整个老年代，就引入了记忆集。有了记忆集，就只需要遍历一部分区域即可。



### 垃圾回收器

---

**Serial**

单线程年轻代垃圾回收器，可以与Serial Old搭配。



**ParNew**

多线程年轻代垃圾回收器，可以与CMS搭配。



**Parallel Scavenge**

也是多线程年轻代垃圾回收器，但侧重点是吞吐量。可以与`Parallel Old`搭配。



**Serial Old**

单线程老年代垃圾回收器。单核可以使用。CMS发生`Concurrent Mode Failure`，会使用Serial Old来清理老年代。



**Parallel Old**

多线程老年代垃圾回收器，侧重吞吐量。可以与`Parallel Scavenge`搭配。

标记整理算法。



**CMS**

CMS也是多线程垃圾回收器，与Parallel相比，CMS侧重点是响应时间、低延迟。

使用标记清除算法。

所以会有内存碎片存在，为了解决这个问题，CMS默认每次进入Full GC时，都会进行碎片整理。

回收有四个阶段：

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清理

其中初始标记和重新标记会stw。



**对CPU资源敏感** ：因为并发清理和并发标记会占用CPU，因此会导致吞吐量下降。

**浮动垃圾** ：并发标记和并发清理用户线程还在运行，可能会产生新的垃圾对象。这些对象无法在这次的GC回收，只能在下次回收时清理。用户线程不仅会产生垃圾，也会产生新对象。为了应对在垃圾回收过程中用户线程产生的新对象，CMS要留有一定的空间备用。CMS在92%时会Full gc。要是备用空间不足用户线程使用，那么就会抛出`Concurrent Mode Failure`，然后调用`Serial Old`来回收。

`-XX:CMSInitiatingOccupancyFraction` 指定CMS使用了多大的空间时开始垃圾回收，默认92%。



**内存碎片**：CMS采用标记清除算法，因此会产生内存碎片。为了应对这个问题，CMS默认每次Full GC时都执行空间压缩。

`-XX:CMSFullGCsBeforeCompaction` ：几次Full Gc进行一次空间压缩，默认为0。即每次都要压缩。



**G1**

G1垃圾回收器，将内存空间分为多个Region。每个Region可以是不同的角色，逻辑上是分代的。从局部上看，G1采用的是复制算法，从整体上看，G1采用的是标记整理算法。



G1的Region中有个区域叫 Humongous，专门用来存放大对象。超过Region一半的对象即会放在这里面。



G1可以通过 `MaxGCPauseMills`来指定最大停顿时间，G1的停顿时间是可预测的。

G1实现可预测的模型，是通过计算回收每个Region的价值来实现的，比如某个Region回收会释放一定的空间，会使用多少时间。G1优先回收那些价值比较大的Region。

G1的Region也会存在跨代引用的情况，解决办法也是通过记忆集。每个Region都有自己的记忆集。G1大概有20%左右的空间用来存放记忆集。



G1也分为四个阶段 ：

1. 初始标记 ：标记GC Root （STW）
2. 并发标记 ：从GC Root开始向下搜索，找对象
3. 最终标记 ：对用户线程暂停，清理并发标记产生的垃圾（STW）
4. 筛选回收 ：对Region的价值进行排序并筛选，回收垃圾（STW）



CMS和G1的区别 ：

1. CMS对cpu资源敏感，G1占用更多内存
2. CMS使用标记清除算法，G1局部上采用复制算法，整体上采用标记整理算法
3. CMS适用于老年代；G1只是逻辑上分代
4. 目标不一样 ：CMS最少暂停时间；G1可预测的停顿时间
5. CMS适用于小内存；G1适用于大内存





### 前端优化

---

前端优化指的是`javac`编译器所做出的优化。Java的优化主要是在后端优化，这样可以让其他的JVM语言也得到优化的好处。

javac的优化有 ：

- 泛型（假泛型）
- 自动拆箱装箱
- 遍历循环（for语句）
- 条件编译
- try-resource
- 等等



**泛型**

Java的泛型是假泛型，这个是由于Java支持泛型时，已经Java5了，必须向后兼容，因此采用了假泛型。

Java不支持原生类型的泛型，放入一个基本数据类型的值，会自动装箱。



**自动装箱拆箱**

自动装箱和拆箱也是Java的语法糖之一。

```java
// 编译时会变成 Integer i = Integer.valueof(10);
Integer i = 10;
// 会变成 int j = i.intvalue();
int j = i;
```



**条件编译**

Javac会省略一些无效的代码段。

```java
if (true){
    print("true");
} else {
    print("false");
}
```

编译之后就会变成 ：

```java
print("true");
```



### 后端优化

---

