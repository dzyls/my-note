### 如何辨别是不是垃圾

---

1. 引用计数法

   无法解决循环引用的情况，Python使用的是这种，但是对循环引用做了特殊处理。

2. 可达性分析

   Java使用的是这种。从GC Root向下遍历，引用链达到的对象即为有效对象。

可以作为GC Root的对象 ：

1. Java虚拟机栈引用的对象
2. 本地方法栈引用的对象
3. 静态变量
4. 常量
5. JVM使用的一些对象（如Class对象、Classloader对象、常用的异常对象）
6. synchroized持有的对象
7. 反应JVM内部情况的对象，如JMX Bean



除此之外，引用也分为：

- 强引用 ：任何时候都不会回收的对象
- 软引用 ：内存不足时回收的对象
- 弱引用 ：下次垃圾回收时回收的对象
- 虚引用 ：没什么用，可以用来接收到对象被回收的通知



**Finalize方法**

finalize方法是对象可以自救的一个方法。

一个对象被回收要经过两次垃圾回收，第一次判断有没有重写finalize方法或者有没有执行，如果此对象需要执行finalize方法，那么将会放到一个低优先级队列中。Java不保证这个finalize方法一定会执行完。

第二次回收判断这个对象之前标记过一次，就会真正的执行。



**不用使用finalize方法关闭资源，使用try-finally**



**方法区（元空间）回收**

元空间存储的是类的二进制信息，当存在以下情况就会回收 ：

- 类的所有实例对象都被回收
- 类的类加载器已经被回收（比如JSP）
- 没有任何一个地方使用了这个类的Class对象，无法通过反射来操作这个类



### 分代收集

---

在垃圾回收中，存在两种极端。

- 大部分对象朝生夕死，很快就会被垃圾回收。
- 少部分对象存活时间很长

针对这两种情况，在之前的垃圾回收器中，都是采用分代收集算法。

存活时间很短的，放在年轻代。存活时间很长的，放在老年代。

年轻代采用复制算法，因为对象很快就会被回收。

根据不同情况，采用不同的处理方法，这也是系统设计或功能设计经常采用的方法。

**但是这种分代，会有另外一个问题 ：跨代引用**

如果老年代引用了某个年轻代的对象，那么要判断这个年轻代对象是否要回收，就要遍历整个老年代了。

针对这种情况，采用了记忆集（Remember Set）。记忆集保存了老年代哪些区域引用了年轻代对象，判断年轻代对象是否被引用，只需要扫描老年代的部分区域即可。



垃圾回收算法有三种 ：

- 复制算法 ：会有空间浪费
- 标记清除算法，会有内存碎片
- 标记整理算法：需要STW



### 垃圾回收的步骤

---

**根节点枚举**

Java是使用可达性分析来做垃圾回收的，因此第一个步骤肯定是找到GC Root。

这个过程称必然要暂停用户线程，以避免用户线程又加了或者减了GC Root。

JVM通过一个OopMap的数据结构来快速找到GC Root。



**安全点**

OopMap的原理是，在可能导致引用变化的指令生成对应的OopMap。但是可能导致引用变化的指令太多了，不可能全部都生成对应的OopMap。因此只在特定的位置来记录这些信息，比如方法调用、循环跳转、异常跳转等。

让所有的线程都到达安全点，停顿下来，一般有两种方式。

- 抢先式中断 ：抢先式中断比较强硬，当需要GC时，直接把所有的线程中断；如果有线程不在安全点上，就回复这个线程。这种是比较低效的。
- 主动式中断 ：当需要GC时，设置一个标志位，然后用户线程都去轮询这个这个标志位，查到就在安全点暂停。



**安全区域**

有些用户线程一直没有得到cpu，一直阻塞或者等待。那么就不能去检查标志位走到安全点。因此引入了另外一个概念 ：安全区域。线程进入安全区域，会标识自己进入了安全区域，这样JVM就不用管这些线程；当线程离开安全区域，会去检测GC Root是否已经完成。由此来保证在遍历GC Root时不会引起引用变化。



**记忆集**

跨代引用，为了避免扫描整个老年代，就引入了记忆集。有了记忆集，就只需要遍历一部分区域即可。



### 垃圾回收器

---

**Serial**

单线程年轻代垃圾回收器，可以与Serial Old搭配。



**ParNew**

多线程年轻代垃圾回收器，可以与CMS搭配。



**Parallel Scavenge**

也是多线程年轻代垃圾回收器，但侧重点是吞吐量。可以与`Parallel Old`搭配。



**Serial Old**

单线程老年代垃圾回收器。单核可以使用。CMS发生`Concurrent Mode Failure`，会使用Serial Old来清理老年代。



**Parallel Old**

多线程老年代垃圾回收器，侧重吞吐量。可以与`Parallel Scavenge`搭配。

标记整理算法。



**CMS**

CMS也是多线程垃圾回收器，与Parallel相比，CMS侧重点是响应时间、低延迟。

使用标记清除算法。

所以会有内存碎片存在，为了解决这个问题，CMS默认每次进入Full GC时，都会进行碎片整理。

回收有四个阶段：

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清理

其中初始标记和重新标记会stw。



**对CPU资源敏感** ：因为并发清理和并发标记会占用CPU，因此会导致吞吐量下降。

**浮动垃圾** ：并发标记和并发清理用户线程还在运行，可能会产生新的垃圾对象。这些对象无法在这次的GC回收，只能在下次回收时清理。用户线程不仅会产生垃圾，也会产生新对象。为了应对在垃圾回收过程中用户线程产生的新对象，CMS要留有一定的空间备用。CMS在92%时会Full gc。要是备用空间不足用户线程使用，那么就会抛出`Concurrent Mode Failure`，然后调用`Serial Old`来回收。

`-XX:CMSInitiatingOccupancyFraction` 指定CMS使用了多大的空间时开始垃圾回收，默认92%。



**内存碎片**：CMS采用标记清除算法，因此会产生内存碎片。为了应对这个问题，CMS默认每次Full GC时都执行空间压缩。

`-XX:CMSFullGCsBeforeCompaction` ：几次Full Gc进行一次空间压缩，默认为0。即每次都要压缩。



**G1**

G1垃圾回收器，将内存空间分为多个Region。每个Region可以是不同的角色，逻辑上是分代的。从局部上看，G1采用的是复制算法，从整体上看，G1采用的是标记整理算法。



G1的Region中有个区域叫 Humongous，专门用来存放大对象。超过Region一半的对象即会放在这里面。



G1可以通过 `MaxGCPauseMills`来指定最大停顿时间，G1的停顿时间是可预测的。

G1实现可预测的模型，是通过计算回收每个Region的价值来实现的，比如某个Region回收会释放一定的空间，会使用多少时间。G1优先回收那些价值比较大的Region。

G1的Region也会存在跨代引用的情况，解决办法也是通过记忆集。每个Region都有自己的记忆集。G1大概有20%左右的空间用来存放记忆集。



G1也分为四个阶段 ：

1. 初始标记 ：标记GC Root （STW）
2. 并发标记 ：从GC Root开始向下搜索，找对象
3. 最终标记 ：对用户线程暂停，清理并发标记产生的垃圾（STW）
4. 筛选回收 ：对Region的价值进行排序并筛选，回收垃圾（STW）



CMS和G1的区别 ：

1. CMS对cpu资源敏感，G1占用更多内存
2. CMS使用标记清除算法，G1局部上采用复制算法，整体上采用标记整理算法
3. CMS适用于老年代；G1只是逻辑上分代
4. 目标不一样 ：CMS最少暂停时间；G1可预测的停顿时间
5. CMS适用于小内存；G1适用于大内存



### 内存分配和回收策略

---

总结一下就几条 ：

- 对象优先在Eden区分配
- 大对象直接进入老年代 ：在ParNew新生代，可以使用`PretenreSizeThreshold`来指定这个阈值
- 年龄超过阈值，对象进入老年代 ：默认15，`MaxTenuringThreshold`来指定这个阈值
- 动态年龄判定 ：如果S区一半的对象都是某个年龄，那么大于等于这个年龄的对象会进入老年代
- 空间分配担保 ：在进行Young GC时，会首先判断老年代的连续空间是否够装下整个年轻代存活的对象。如果可以装下，那么这次GC是安全的。如果是不安全的状态，那么就要根据是否允许内存担保失败。如果允许冒险，那么就会进行Young GC；如果不允许冒险，那么会进行一次Full Gc。`HandlePromotionFailure`打开可以避免过度Full GC。JDK6后默认关闭，内存担保失败即会进行Full GC。



JVM调优小tips ：

JVM一般情况是不需要参数调优的，只需要根据需要指定最小最大的堆和元空间大小。根据需要选择合适的GC回收器。比如内存小并且要求吞吐量选择Parallel收集器；内存小要求相应时间，那么就选择CMS + ParNew；如果内存大，则选择G1。

只有某些特殊情况需要参数调优。比如 ：

- 程序经常申请大对象，比如大数组、大的文本或者图片，那么就需要将`PretenreSizeThreshold`调大，同时也要稍微调整新生代和老年代的比例（默认1:2），但也不能将老年代调的太小，否则将会内存担保失败然后Full GC。



更多调优案例 ：参考

[JVM调优]: https://zhuanlan.zhihu.com/p/363961261	"JVM调优"



### 常用的JVM命令

---

**jps**

jps是查看Java进程的，这个命令只显示Pid和进程名。

在linux系统可以用 *pwdx `ps -ef | grep java | grep -v | awk ‘{print $2}’ `*  来显示Java进程和路径。



**jmap**

jmap常用来看内存镜像，比如 ：

`jmap -dump pid`

也可以看对象的统计，这一点可以用来排查是否有内存泄露 ：`jmap -histo pid`



**jstat**

jstat 可以用来看虚拟机GC情况，比如 ：

`jstat -gc`、`jstat -gcutil`、`jstat -gcnew` 、`jstat -gcold`

可以搭配`jcmd pid GC.run`来调用GC，看内存回收是否有效，依次来排查当前是否存在内存泄露。



**jinfo**

jinfo是用来看Java进程的启动参数的。

比如 `jinfo -flag +name`这种。



**jstack**

jstack通常用来排查死锁，表现为cpu占用高。

先用`top`查找占用cpu最高的进程，然后用`top -Hp pid`查看占用cpu最高的线程，再然后将线程id转换为16进制，再之后使用`jstack -l tid`查看线程是否死锁。



另外补充一个Arthas的`trace`命令，使用这个命令可以查询方法中的每个步骤的耗时。

这个在压测时用来找性能瓶颈，找到耗时的操作，优化一些不需要的操作。

我就曾经用这个命令，在压测时，发现`new Xstream()`这个步骤很耗时。点进注释发现这个类是线程安全的。不需要重复new。



### new一个对象的过程

---

当JVM遇到一个new指令时，它会先去检查这个类有无加载过。如果没有加载过，那么就会走类加载机制、双亲委派模型。

之后就会给这个对象申请内存，对象的大小在类加载后即可确定。申请内存的方式，通常由有指针碰撞、空闲列表。为了确保对象创建的线程安全性，通常使用TLAB（本地线程内存分配缓冲）。哪个线程申请内存，那么就在哪个线程的TLAB中申请内存。在TLAB是不需要加锁的，只有当线程的TLAB用完了，再申请一块TLAB时才加锁。

> 除了TLAB，还有CAS方式可确保申请内存线程安全性。

再之后就是赋零值。

之后是设置对象头，包括（这个对象是哪个类的实例、对象的hashcode、对象GC年龄等等）。



**最后才是执行构造函数。**



总结一下 ：

1. 检查类是否有加载，如果没有就加载
2. 申请内存，指针碰撞或空闲列表，（TLAB或CAS保证安全）
3. 设置零值
4. 设置对象头（对象头中有GC年龄、Hash码、锁标志位、是哪个类）
5. 执行构造函数



### 类加载过程

---

类加载过程是一个老生常谈的问题，但实际在工作中并不会使用到太多，所以如果没有经常回顾，很快就会遗忘。

**加载**

要加载类，肯定是要先找到这个class文件。无论是这个class是在本地还是远程，都要先转换为二进制流，然后根据二进制流转换为方法区（元空间）的运行时的数据结构。然后在堆中生成一个Class对象，作为访问这个类的访问的入口（反射的原理）。



**验证**

既然class文件都读取了，那肯定要做一下验证咯，不然你这class文件不保熟咋办。

验证大致有 ：文件格式验证（Java版本号验证）、元空间验证（检查父类相关）、字节码验证（类型转换等）、符号引用验证（符号验证）。



**准备**

验证完了，那肯定要做一些准备工作了。

回想一下，静态变量又叫做类变量，因为静态变量是属于类的，而非静态变量是属于对象的。

准备阶段就是将静态变量初始化零值。



**解析**

解析就是将符号引用替换为直接引用。

符号引用 ：就是一个符号来标识引用的目标。

直接引用 ：指针或者偏移量来表示所引用的目标。



**初始化**

执行clinit方法（静态变量赋值、静态代码块）。

注意，clinit不是构造函数。clinit是javac编译器自动生成的。javac会自动收集所有的静态变量赋值和静态代码块，然后组合成一个clinit方法。



有一个需要注意的点 ：**clinit方法中的代码顺序和Java文件的的静态代码顺序有关**

```java
class Demo{
    static {
        i = 0; // 可以赋值但是不能访问
        print(i); // 编译器 ：非法向前引用
    }
    static int i = 1;
}
```



Java虚拟机会保证子类的clinit方法执行前，父类的clinit已经执行完毕。



clinit方法是加锁的，所以不要在clinit方法里写死循环。





### 类加载器

---

Bootstrap ClassLoader 加载 JAVA_HOME/lib 路径下的类

Ext Classloader JAVA_HOME/lib/ext路径下的类

Application ClassLoader  classpath路径下的类



**双亲委派模型**

加载器加载类时，总会先去请求父类加载器去加载。父类也会请求自己的父类，直到Bootstrap classloader。如果父类不能加载，子类加载器才会去尝试去加载。

这样做的好处 ：

- 避免重复加载类
- 保证安全性，比如java.lang.String这个类是不能被加载的



**破坏双亲委派机制**

Classloader类中有两个方法 ：loadClass和findClass。loadClass就是双亲委派的实现（调用父类加载），findClass则是类加载器的加载类的方法。

因此打破双亲委派，只需要重写loadClass方法即可。



### 类卸载

---

类卸载很少遇到，但有一些情况会遇到，比如传说中的jsp。

类卸载有三个前提条件 ：

- 该类所有实例都被回收
- 该类的类加载器也被回收
- 代表该类的Class对象也被回收（即没有使用反射生成该类）

就会发生类卸载。



说起类卸载，就要提一下为什么要类卸载。在学习双亲委派模型时，通常会提一嘴说打破双亲委派模型的方法是重写loadClass方法。而Tomcat就打破了双亲委派模型。

Tomcat打破双亲委派模型主要是有以下刚需：

- 需要热部署，写了一个jsp扔上去替换就能热部署了
- 一个Tomcat可以发布多个模块，而不同模块之间可能使用了不同版本的jar，导致有全限定名相同的类存在

基于这些原因，Tomcat必须要打破双亲委派模型。

tomcat中自定义了多个Classloader，其中有两个 ：

- WebAppClassloader ：加载的类只有当前的模块可见
- JasperClassloader ：加载jsp的Classloader。如果要卸载这个jsp，只需要重新new一个JasperClassloader即可。

Jsp文件是可以热部署的，如果jsp文件反复热部署，并且不能卸载类的话，那么元空间迟早爆掉。因此必须要实现类卸载功能。



再重复一次，类卸载有三个条件：

- 该类的实例全部被回收
- 代表该类的Class对象也被回收
- 加载该类的Classloader也被回收

达成这三个条件，即可触发类卸载机制。



### 前端优化

---

前端优化指的是`javac`编译器所做出的优化。Java的优化主要是在后端优化，这样可以让其他的JVM语言也得到优化的好处。

javac的优化有 ：

- 泛型（假泛型）
- 自动拆箱装箱
- 遍历循环（for语句）
- 条件编译
- try-resource
- 等等



**泛型**

Java的泛型是假泛型，这个是由于Java支持泛型时，已经Java5了，必须向后兼容，因此采用了假泛型。

Java不支持原生类型的泛型，放入一个基本数据类型的值，会自动装箱。



**自动装箱拆箱**

自动装箱和拆箱也是Java的语法糖之一。

```java
// 编译时会变成 Integer i = Integer.valueof(10);
Integer i = 10;
// 会变成 int j = i.intvalue();
int j = i;
```



**条件编译**

Javac会省略一些无效的代码段。

```java
if (true){
    print("true");
} else {
    print("false");
}
```

编译之后就会变成 ：

```java
print("true");
```



### 后端优化

---

**解释器和编译器**

Java是既有解释器，又有编译器。

之所以两个共存，是因为解释器启动较快，当需要快速启动时，使用解释器可以获得较好的启动速度。

而编译器虽然启动慢，但后续优化好，慢慢的将越来越多的代码编译成本地代码，运行速度就越来越快。

使用`-Xint`使用解释模式，

使用`-Xcomp`使用编译模式



**编译器优化**

1. 方法内联
2. 锁消除（基于逃逸分析）
3. 栈上分配（基于逃逸分析）
4. 标量替换（基于逃逸分析）
5. 公共表达式消除
6. 数组边界检查消除





### 线程和协程

---

每个线程默认情况占1M内存（`-Xss/-XX:ThreadStackSize`），线程切换也会有很大的消耗（用户态系统态切换、线程）