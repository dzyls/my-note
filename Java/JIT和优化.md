### 解释还是编译

---

JVM有自己的硬件架构，比如寄存器、处理器、堆栈。

Java程序在运行时，需要使用`javac`来将程序来编译，然后通过`java`来将`.class`文件翻译为二进制，由JVM加载运行。

在这个过程中，`javac`就是编译器，`java`就是解释器。

通过JVM来屏蔽了不同系统的不同，编译和解释两步实现了跨平台的特性。



因此从这个角度来说，Java即有编译，也有解释。



### JIT

---

对于只运行一次的代码，只要编译即可，不需要进行特殊的优化。优化这个过程再快，也比没有优化直接运行慢一些。

但是对于一些热点代码，在第一次解释时进行优化，就可以加快后面的执行速度。

**热点代码**

- 多次运行的方法
- 多次调用的循环

判断是否是热点代码，就需要对方法、循环的调用次数来统计。达到了阈值，则用JIT优化。后续再次调用时，发现存在本地代码，则直接运行，不用再次编译了。

对热点代码，就由JIT（just in time）即时编译器来进行优化。

![img](https://upload-images.jianshu.io/upload_images/6753966-b3130d7739d13d86?imageMogr2/auto-orient/strip|imageView2/2/w/700/format/webp)

JIT进行的优化有 ：

- 方法内联 ：将被调用的方法复制到调用的方法中
- 逃逸分析 ：分析对象有没有逃逸出方法（即对象有没有被其他方法调用），如果没有，可以进行一些更深层的优化 ：
  - 栈上分配 ：对象直接在栈上分配，减少GC压力
  - 锁消除 ：只有一个线程使用锁，那么就可以不上锁了
  - 标量替换 ：引用类型的数据，可以继续被分解、替换。
- 数组范围检查 ：每次读写数组时，都要判断一下是否越界。JIT优化后，可以免去这个检查。
- 分支预测
- 消除无用代码



### JIT编译模式

---

**C1** ：`-client`启动较快

**C2** ：`-server`启动较慢，但后续较快