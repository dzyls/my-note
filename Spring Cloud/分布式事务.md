## 分布式事务简介

先回忆一下事务的四大特性 ：ACID。

A ：原子性，一个事务要么全都执行，要么全都不执行。

C ：一致性，事务执行前后数据是一致的。

I ：隔离性，两个事务的互相隔离。通过锁和MVCC来确保。

D ：持久性，事务一旦提交，对数据的影响是持久的。通过Redo Log和bin log来确保。



单体架构事务实现没什么复杂的，直接使用数据库就可以。

但是微服务架构呢，业务系统、分库分表都是常见的，如何确保分布式事务的正确呢？



## 分布式一致性解决方案



### 2PC 两阶段提交

---

 两阶段提交很容易理解，引入了一个事务管理器的角色，两阶段分别是 ：

1. 事务管理器通知资源管理器准备事务开始，并告知将结果告知给事务管理器，是为准备阶段
2. 如果所有资源管理器都执行成功了，那么就事务管理器就告知所有的资源管理器发送提交事务的指令；如果有一个资源管理器执行失败了，那么事务管理器就通知其他资源管理器执行回滚事务。如果超时了，事务协调者还是没有收到全部的结果，那么就会通知回滚。



2PC 优点是很简单，就是有一个第三方去执行告知和统计，如果有一个失败，就让所有的资源管理器执行回滚。

但缺点却有很多 ：

- 同步阻塞，等待事务管理器通知结果时是阻塞的
- 过于保守，有一个执行失败就回滚
- 依赖于事务管理器，事务管理器挂掉了就永久阻塞了。解决方案是引入一个备份的事务协调者。
- 脑裂问题，某一些资源管理器没有收到commit指令，那么就会出现数据不一致的情况



**2PC在提交阶段如果某个参与者挂掉了，是会出现数据不一致的情况。**



### 3PC 三阶段提交

---

三阶段提交是二阶段提交的升级版，二阶段有个致命的问题就是，如果事务管理器不发指令，那么资源管理器就会一直阻塞，这是特别低效且致命的。

三阶段使用了超时机制来解决了阻塞的问题。

三阶段分别是 ：

1. CanCommit : 事务协调者向参与者发送事务执行请求，询问是否可以执行事务，参与者只需要回答是或否，没有具体的事务操作，并且有超时终止的机制
2. PreCommit : 事务协调者根据CanCommit返回的结果来决定是否执行，如果所有的参与者都回复可以执行，那就发送PreCommit，这时参与者才会真正的执行事务、写redo log和undo log，但不提交事务，并向协调者返回ACK响应。如果有一个参与者返回了否，那就事务协调者就发送事务终止指令。
3. DoCommit : 这一步也是根据上一步的结果来决定是提交还是回滚。如果所有的参与者都返回了成功，那么协调者就通知提交；如果有一个返回了失败，那么事务协调者就通知回滚。

三阶段提交相比二阶段提交有以下优点 ：

1. 引入了CanCommit阶段，可以尽早发现不能执行事务的情况，比如某个节点挂掉了、不能获取锁
2. 参与者也有了超时机制，超时释放资源，这样避免了协调者挂掉了一直阻塞的问题。



**3PC的参与者也引入了超时释放机制，但是在DoCommit阶段某个节点挂掉，依然会出现数据不一致的情况**



