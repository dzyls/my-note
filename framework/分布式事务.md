## 分布式事务简介

先回忆一下事务的四大特性 ：ACID。

A ：原子性，一个事务要么全都执行，要么全都不执行。

C ：一致性，事务执行前后数据是一致的。

I ：隔离性，两个事务的互相隔离。通过锁和MVCC来确保。

D ：持久性，事务一旦提交，对数据的影响是持久的。通过Redo Log和bin log来确保。



单体架构事务实现没什么复杂的，直接使用数据库就可以。

但是微服务架构呢，业务系统、分库分表都是常见的，如何确保分布式事务的正确呢？



## 分布式一致性解决方案



### 2PC 两阶段提交 XA

---

 两阶段提交很容易理解，引入了一个事务管理器的角色，两阶段分别是 ：

1. 事务管理器通知资源管理器准备事务开始，并告知将结果告知给事务管理器，是为准备阶段
2. 如果所有资源管理器都执行成功了，那么就事务管理器就告知所有的资源管理器发送提交事务的指令；如果有一个资源管理器执行失败了，那么事务管理器就通知其他资源管理器执行回滚事务。如果超时了，事务协调者还是没有收到全部的结果，那么就会通知回滚。



2PC 优点是很简单，就是有一个第三方去执行告知和统计，如果有一个失败，就让所有的资源管理器执行回滚。

但缺点却有很多 ：

- 同步阻塞，等待事务管理器通知结果时是阻塞的
- 过于保守，有一个执行失败就回滚
- 依赖于事务管理器，事务管理器挂掉了就永久阻塞了。解决方案是引入一个备份的事务协调者。
- 脑裂问题，某一些资源管理器没有收到commit指令，那么就会出现数据不一致的情况



> 在分布式系统中，最好不要直接写别人的库。直接操作别人的库，可能会把别人的库搞挂掉。**必须通过接口来间接操作别人的库！**



**2PC在提交阶段如果某个参与者挂掉了，是会出现数据不一致的情况。**



### 3PC 三阶段提交

---

三阶段提交是二阶段提交的升级版，二阶段有个致命的问题就是，如果事务管理器不发指令，那么资源管理器就会一直阻塞，这是特别低效且致命的。

三阶段使用了超时机制来解决了阻塞的问题。

三阶段分别是 ：

1. CanCommit : 事务协调者向参与者发送事务执行请求，询问是否可以执行事务，参与者只需要回答是或否，没有具体的事务操作，并且有超时终止的机制
2. PreCommit : 事务协调者根据CanCommit返回的结果来决定是否执行，如果所有的参与者都回复可以执行，那就发送PreCommit，这时参与者才会真正的执行事务、写redo log和undo log，但不提交事务，并向协调者返回ACK响应。如果有一个参与者返回了否，那就事务协调者就发送事务终止指令。
3. DoCommit : 这一步也是根据上一步的结果来决定是提交还是回滚。如果所有的参与者都返回了成功，那么协调者就通知提交；如果有一个返回了失败，那么事务协调者就通知回滚。

三阶段提交相比二阶段提交有以下优点 ：

1. 引入了CanCommit阶段，可以尽早发现不能执行事务的情况，比如某个节点挂掉了、不能获取锁
2. 参与者也有了超时机制，超时释放资源，这样避免了协调者挂掉了一直阻塞的问题。



**3PC的参与者也引入了超时释放机制，但是在DoCommit阶段某个节点挂掉，依然会出现数据不一致的情况**



## CAP和BASE理论

CAP定理，简单来说是指，在一个分布式系统不可能同时满足C【强一致性】、A【可用性】、P【分区容错性】这三者，只能选择其中两者。

> 分区容错性是指在分布式系统中遇到任何网路分区故障，系统仍然可以对外正常提供服务。
>
> 网络分区故障，指由于网络故障，导致集群分为多个独立的区域，这就是网络分区。

分布式系统中，网络并非绝对可靠，即使出现网络故障仍然能保证系统对外服务，所以分区容错性必然需要。

如果出现了网络分区故障，如果要保证数据的一致性，那么就必须要拒绝服务，因此选了C就不能选A。

如果要保证即使出现了分区故障，要提供服务就必须牺牲数据的一致性。

因此CAP通常选CP和AP。

CP ：放弃了可用性，保证数据的一致性。二阶段提交和三阶段提交都属于CP。用户体验很差。

AP ：放弃了一致性，保证了可用性，用户的体验相对较好，一致性可以用其他手段来保证数据最终一致性。



**BASE理论**

BASE理论是基于CAP理论延伸的理论。

BA指基本可用，分布式系统出现故障后，允许一部分功能不可用，保证核心系统的可用性。

S 指软状态，即数据可以处于中间状态，【由于同步延时】允许数据一段时间内在不同节点不一致。

E 指最终一致性，数据在中间阶段的一段时间后，最终会达到最终一致性。



BASE没有要求数据强一致性，而是允许数据在一段时间内是可以不一致的，数据在经过一段时间后最终达到一致。



互联网产品大部分会选择BASE理论来实现数据的一致性，因为可用性相比于强一致性对用户更重要。

比如，下单时，系统不需要同步等待用户的支付结果，而是等第三方支付平台支付处理成功后，再更新系统的状态即可。虽然系统内的订单支付状态与第三方支付平台的支付状态存在一段时间的不一致，但是并不影响用户使用，这样用户的体验更好。



## 分布式事务的落地方案

上文介绍了2PC和3PC，这两个理论都确保了CP而不是确保AP，也就是可用性低，强一致性方案效率低【2PC和3PC也会出现不一致的情况，比如参与者在最后一个阶段挂掉的情况】，并且体验不好。

真正落地的方案通常是基于2PC或3PC理论，再结合BASE理论来保证基本可用和软状态，实现数据的最终一致性。



### TCC

---

TCC是一种两阶段提交的思想。

T是指Try，

CC值得是Confirm和Cancel。

在Try阶段执行准备工作，在Confirm和Cancel阶段执行提交或者取消。

Try ：锁定资源或预留资源，修改为锁定状态。

Confirm ：执行实际的操作。

Cancel ：任何一个服务的业务出错，那么这里就需要补偿【比如说扣钱了就加回去，加钱了就扣回去】，和释放资源。

本质上就是两阶段提交的思想，分布式场景中，主业务调用每个服务，Try阶段进行锁定资源，如果Try阶段都获得了所有资源，那么就会进入Confirm阶段执行实际的操作。如果Try阶段有服务没有获得资源，那么就会调用Cancel回滚。

TCC框架会记录分布式事务的操作，避免某个服务宕机导致数据不一致，如果出现宕机，TCC框架会重试，因此需要确保幂等性。



一般不会选这种方案，因为补偿的方案会导致代码很难维护。很复杂，一般跟钱相关的才会选用这种。



### 基于可靠性消息实现最终一致性方案

---

最终一致性方案就是使用MQ了，RocketMQ有一个事务消息的玩法。

**为什么要必须使用事务消息的方法来写？**

假设使用普通消息，步骤是 :

```sql
begin transation;
sendMQMsg();
update();
commit;
```

如果发送消息成功，但执行update失败，会导致其他系统以为要执行事务，导致其他的执行了，但本地的由于异常没执行，会数据不一致。

另一种方式也会有 :

```sql
begin transation;
update();
sendMqMsg();
commit;
```

假设本地事务执行成功，但发送MQ消息时超时异常回滚了，但其实发送成功了，其他系统也会以为要执行事务，导致数据不一致。



**因此必须要使用事务消息！**



RocketMQ针对上述的两种场景提出了一个事务消息。

即半消息。步骤是 ：

1. 本地先发送半消息【half 消息】，这个半消息此时其他消费者看不见的。
2. 然后执行本地事务，本地事务成功，才发送确认消息。RocketMQ收到确认消息了，之前的半消息才能被消费。
3. 如果生产者一直没有提交确认消息，那么RocketMQ会定时回查状态，如果状态是已经成功，那么也会将半消息给消费者消费。【这个避免了本地事务执行成功，但确认消息没发出去的场景，如果没有回查接口，那么就会出现不一致的场景】
4. 由于消息队列的至少一个消费的特性，当消费者事务不成功，会重复投递。因此依赖这个不成功就重复投递的策略，就可以保证事务的最终一致性。



RocketMQ事务消息根据两个特性 ：

- 回查接口，避免事务执行成功但确认消息发送失败导致数据不一致的场景
- MQ的失败重复投递特性，事务执行失败会继续重试

这两种特性来实现最终一致性。



### 最大努力通知型

---

最大努力通知型和基于可靠消息实现最终一致性方案类似。

也是执行不成功就重试，重试到一定次数就放弃。

这种适合那种数据一致性要求不高的场景，是柔性事务。



举个不恰当的例子 ：

- 用户在商户买东西，调用支付平台支付
- 用户支付完成后，支付平台告知商户支付结果，如果商户确认了结果就成功，如果商户一直没确认，那就一直重试。
- 重试到一定次数就放弃，修改状态
- 放弃了，但会有一个查询接口，供商户去根据订单号查询支付结果。

## Seata

Seata是一款开源的分布式事务框架，

支持TCC、Saga、XA和AT，Seata主推AT模式。

什么是Saga、AT？

### Saga

---

Saga模式又称长事务解决方案。主要解决的是，没有两阶段提交的情况下如何解决分布式事务问题。

核心思想是，将一个长事务分解成多个短事务。每个参与者都向处理本地事务一样执行。当一个参与者执行失败了，其他参与者则通过补偿机制补偿前面已经成功的参与者。

和TCC类似，但没有Try阶段，直接进入到执行提交阶段。

TCC和Saga都挺麻烦的，要补偿，代码上并不容易维护。

并且补偿还有可能执行失败，这种情况就要人工干预了。



Saga的优点 ：

- 没有Try阶段，一阶段直接执行，并且可以异步执行。

缺点 ：

- 不支持原子性和隔离性，这个问题在某些场景下会有很大的问题，比如用户下单的操作，下单是一个长事务，送积分的事务执行成功了，但其他事务的执行失败了，用户在收到积分时直接用掉了，这个时候执行回滚操作会有问题。



Saga有两种协调模式 ：

1. 事件\编排模式：去中心化的，每一个服务执行完本地事务，就发布一个事件，当所有的服务都执行完，则事务执行完毕。有一个发出失败的事件，则回滚。
2. 命令\协调模式 ：有一个Saga协调器，负责统筹全局。某一个服务想Saga协调器申请执行事务，然后Saga协调器协调相关服务执行事务，任何一个服务执行事务失败，Saga协调者都要命令已执行事务的服务回滚事务。



### AT

---

AT模式是Seata主推的一种分布式事务解决方案，基于XA方案演进而来。

这种方法分为三大模块：

1. TM【Transaction Manager】：事务管理器
2. RM【Resource Manager】：资源管理器，可以简单理解为数据库资源
3. TC【Transaction Coordinator】：事务协调器

其中TM和RM要和客户端业务集成部署，TC则要独立部署。



具体的步骤如下 ：

1. TM向TC注册全局事务，生成一个全局唯一的XID
2. RM向TC注册分支事务，并将其纳入XID的全局事务范围
3. RM向TC汇报资源的准备状态
4. TC收集所有的执行状态，决定事务是提交还是回滚
5. TC通知所有的RM要提交还是回滚



AT模式基于XA方法演进而来，也是一个两阶段提交的事务模型。和XA相比，做了很多优化。