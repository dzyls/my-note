### 内存管理

---

进程使用的并不是真实的内存空间，而是把实际的内存地址做了一个转换，操作系统会为每个进程分配独立的一套虚拟地址。

进程使用的内存地址是**虚拟地址**。

计算机硬件的内存地址是**物理地址**。



**为什么需要用虚拟地址？**

在上古时代，进程是直接使用物理地址的，这样会有一个问题，一个进程可以修改其他进程的内存空间，这样会有安全性的问题。

使用虚拟地址，每个进程使用的内存



那么怎么通过虚拟地址找到物理地址呢？

这个翻译官就是CPU芯片中的内存管理单元【MMU】，MMU会通过将虚拟地址转换为物理地址。



### 内存分段

---

内存分段比较容易理解。分段的虚拟地址由两部分组成，段号和段基地址。

通过段号可以找到段基地址，通过段基地址可以找到物理内存的地址，再加上段内偏移量就可以得到试用的物理内存了。



内存分段简单粗暴，但是有个缺点，会有内存碎片。

举个不恰当的例子，八个人去吃饭，坐在八个位置的桌子上，走了两个，但空位不相邻，这时候来了两个人要求要坐在一起，这个时候位置是坐不了的。



这种情况，可以将部分内存中的内容放到磁盘上，然后再放到内存里，这样会有一个问题 ：

- 置换到磁盘，会导致应用运行很慢，卡顿



内存分段是有内存碎片的问题，于是提出了另外一种内存管理的方式 ：



### 内存分页

---

内存分页可以解决内存碎片的问题，内存分页的思想就是将内存分成一段段固定的尺寸，这样一个连续并固定的空间叫页。在Linux下，每页为4KB。

通过 **页表** 由虚拟地址找到物理地址，虚拟地址是连续的，但物理地址不一定是的。

通过这种将页拆小，并使用映射，虚拟空间连续但物理空间不连续，就解决了内存碎片的问题。

同时将最近没被使用到的页存放到磁盘上，一次性写入的是少数几个页，数量少，再读回时速度也快。



但是内存分页还有一些缺点 ：

1. 内部页内存浪费

   固定是4KB，可能都没用到4KB，这样这个页就浪费了。

2. 页表占用空间问题

   32位环境下，4GB内存，一页是4KB，那就需要2 ^ 20个页，每个页的地址占4个字节，那就是需要 4 * 2 ^ 20，也就是4MB。

   一个进程要4MB，那100个进程就是400MB，这相比于4GB是一个很大的占用了。



解决页表占用空间的问题，提出了多级页表。

**多级页表**

在32位的机器上，分为两级页表。

第一级页表中存放的是二级页表的地址，而二级页表存储的是真实的页物理地址。

一级页表有1024个，二级页表也是有1024个，二级页表每项存储的是4KB页的物理地址，二级页表按需加载，用到才加载。

这样就是 4 KB * 1024 * 1024 ,两级页表最多可以表示4GB，这对32位机器是够用的。



那么在64位机器呢？

64位机器分了4级页表，每级页表也是1024个。



多级页表虽然节省了空间占用，但找到一个页需要多级转换，效率上是较低的。

解决这个问题，引出了 **TLB**。

将最近使用的页的地址存到TLB缓存中【页表缓存】，先在TLB中找，如果没找到再去页表找，这样就提升了效率。



### 内存段页

---

内存分段和分页不是相对的，可以结合使用的。

先将内存分段，再在段的基础上去分页。

结构是 ：

通过段表找到段页表项，段页表中存放的是真正的物理地址。