### 为什么要分用户态和内核态

---

最主要的原因是**权限分级**。

**Cpu指令**

指令集是软件操作硬件的媒介。

每一条汇编语句，对应一条指令。

很多个指令汇聚在一起，就是指令集。



Cpu指令是有权限分级的，有些指令是操作硬件的，如果操作的不规范，会影响到整个系统。

硬件的操作是复杂的，可能会出问题的。因此操作系统禁止软件直接操作硬件的可能，只能通过系统调用来简介操作硬件。



### 用户态和系统态

---

用户态和系统态就是权限分级的结果，系统态是高权限，用户态是低权限。

用户态需要使用高权限的指令，只能通过切换到高权限的指令。

比如进程要处理IO，进程会执行函数切换到系统态，

用户态切换到系统态是比较耗费资源的，它需要完成 ：

- 保留用户态执行的现场
- 复制用户态参数，并检查参数是否有危害
- 执行内核态代码
- 复制执行结果，切换到用户态
- 恢复用户态现场【寄存器、上下文、用户栈】



**触发用户态切换到系统态的情况**

1. 系统调用 ：比如fork函数
2. 中断 ：外围设备完成请求后，会向CPU发送中断信号，CPU会转到中断信号对应的进程中去处理
3. 异常 ：如缺页异常



### 线程和协程

---

多任务操作，我们会很自然的想到使用多线程去处理。

比如，一千个任务，了不起用一千个线程去处理。

但是某一天并发量持续提升，到达需要一万个任务同时执行怎么处理？

还是用多线程吗？

使用多线程会占用内存，一个线程占用内存至少4M，10000个就是40G了。

虽然内存便宜，但也不是这样玩的，提升内存容量的同时，CPU和磁盘也要同步的提升【短板原理嘛】。



有一种方案是，搞集群，前面加个负载均衡，这个方案比较贵，系统复杂性也会提升。

还有一种方案是，使用**协程**。



线程有两个缺点 ：

- 占用内存比较高
- 线程切换比较耗时，有时切换一次甚至比线程执行时间还长



协程就是来解决这个问题的。

操作系统是没有协程这个概念的，协程是基于系统级线程的，协程又叫用户级线程。

一个线程可以有多个协程，每个协程执行完一段时间后就会主动让给别的协程去运行，这样每个协程都有机会运行。

由于都在同一个线程上，协程之间的切换就没有那么耗时，也不涉及用户态、系统态的切换。

协程中不要调用线程的阻塞操作，这样会阻塞到其他协程。



协程最好与异步IO搭配，这样才能发挥最大的能力。

在计算密集型的任务，协程并不能获得提升，因为计算密集型的任务线程切换并不多。

